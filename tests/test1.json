{
    "test_name": "파이썬",
    "qna": [
        {
            "question": "파일 입출력 프로그램 구조 설명",
            "answer": "파일 입출력 프로그램은 파일을 열고, 읽거나 쓰고, 닫는 3단계 구조로 이루어진다.\n\n첫째, 파일 열기 단계에서는 open() 함수를 사용하여 파일을 열고 파일 객체를 생성한다. 이때 파일의 용도에 따라 읽기(r), 쓰기(w), 추가(a) 등의 모드를 지정하며, 한글이 포함된 텍스트 파일의 경우 encoding='utf-8'과 같은 인코딩 방식을 함께 지정한다.\n둘째, 파일 읽기/쓰기 단계에서는 열린 파일 객체를 통해 데이터를 처리한다. 읽기 작업에는 read(), readline(), readlines() 함수가 사용되며, 쓰기 작업에는 write() 함수를 사용하여 문자열 형태의 데이터를 파일에 기록한다. 이 과정에서 반복문을 활용하면 파일의 끝(EOF)까지 데이터를 순차적으로 처리할 수 있다.\n셋째, 파일 닫기 단계에서는 close() 함수를 호출하여 파일과의 연결을 해제한다.파일을 닫지 않으면 데이터 손실이 발생하거나 다른 프로그램에서 파일 접근이 불가능해질 수 있다.이를 방지하기 위해 with ~ as 구문을 사용하면 코드 블록이 종료될 때 파일이 자동으로 닫히도록 할 수 있다."
        },
        {
            "question": "예외처리 프로그램 구조 설명",
            "answer": "예외처리는 프로그램 실행 중 발생할 수 있는 오류를 우아하게 처리하여 프로그램이 비정상 종료되지 않도록 하는 구조이다.\n\n기본적인 예외처리 구조는 try – except 구문으로 이루어진다. try 블록에는 오류가 발생할 가능성이 있는 코드를 작성하고, except 블록에는 해당 오류가 발생했을 때 실행할 처리 코드를 작성한다. 이를 통해 오류 발생 시 사용자에게 알림을 제공하고 프로그램의 흐름을 제어할 수 있다.\n필요에 따라 다중 except 구문을 사용하여 여러 종류의 예외를 각각 처리할 수 있으며, else 구문을 사용하면 예외가 발생하지 않았을 경우 실행할 코드를 작성할 수 있다.\n또한 finally 구문을 사용하면 예외 발생 여부와 상관없이 항상 실행되는 코드를 작성할 수 있으며, 주로 파일을 닫는 등의 정리 작업에 활용된다. raise 문을 사용하면 개발자가 의도적으로 예외를 발생시킬 수도 있다."
        },
        {
            "question": "TkInter 프로그램 동작 순서",
            "answer": "1. 메인창 생성: Tk 객체를 생성한다, ex: [ win = Tk() ]\n2. 위젯 생성: Label, Button 등의 GUI 컴포넌트(위젯)을 생성한다, ex: [ label = Label(win, text='Hello') ]\n3. 위젯을 창에 배치: 생성된 위젯을 메인 창에 배치한다, ex: [ label.pack() ]\n4. 메인 루프 실행: GUI 화면 완성 및 이벤트 처리를 시작한다, ex: [ win.mainloop() ]"
        },
        {
            "question": "파이썬 디버깅의 pdb 명령어(자주 쓰이는 것 위주)",
            "answer": "h, help: pdb 명령어 리스트 출력\nw, where: 코드 trace 출력\nl, list: 소스코드 출력 (현재 위치 포함)\nb, break 라인번호/함수명: 해당 라인/함수 첫 실행 라인에 breakpoint 지정\ncl, clear 라인번호: 라인번호의 breakpoint 삭제 (라인번호 없으면 모든 breakpoint 삭제)\nc, continue: 다음 breakpoint까지 실행\ns, step: 다음 단계 (함수 내부로)로 진행\nn, next: 다음 단계 (문장) 수행\nr, return: 현 함수의 return 전까지 수행\np 변수명, print(변수명): 변수 값 출력\n!변수명 = 값: 변수 값을 변경q, quit: 디버거 종료"
        },
        {
            "question": "클래스와 객체의 속성 차이",
            "answer": "클래스 속성: 모든 객체가 공유하므로 객체 전체가 공용으로 사용해야 하는 값을 지정할 때 사용한다.\n\n객체 속성: 객체 별로 독립되어 있어, 각 객체가 값을 독립적으로 관리해야 할 때 사용한다."
        },
        {
            "question": "클래스와 객체의 메서드 종류",
            "answer": "1. 인스턴스 메서드: 메서드 첫 번째 매개변수는 항상 객체 자신을 의미하는 self 파라미터로 고정, 가장 흔하게 사용되는 메서드, 메서드를 호출한 객체에만 영향을 미침, 객체 속성에 접근 가능함\n\n2. 클래스 메서드: 메서드 첫 번째 매개변수는 self 대신 클래스를 의미하는 cls 파라미터, 클래스 속성에만 접근 가능하고, 객체 속성 및 메서드에는 접근 불가능, 클래스 자체에서 직접 호출됨, @classmethod라는 데코레이터를 붙여 클래스 메서드임을 표시함, cls를 사용하여 메서드 내부에서 현재 클래스의 새로운 인스턴스를 생성 가능함, 객체 생성 없이 호출 가능함\n\n3. 정적 메서드: self 파라미터가 없어 객체 속성 및 메서드에 접근 불가능함, 클래스 이름으로 메서드를 직접 호출함, 객체와 독립적임, @staticmethod 데코레이터를 붙여서 정적 메서드임을 표시함, 상호작용을 배제하고 일관된 활용을 보장하는 함수를 만들 때 사용함, 객체 생성 없이 호출 가능함"
        },
        {
            "question": "클래스 비공개 속성, 메서드",
            "answer": "'__속성 = 값', 'def __메서드()' 형태로 정의. 클래스 내부에서만 접근 가능"
        },
        {
            "question": "클래스의 매직 메서드",
            "answer": "__new__: 새로운 객체를 생성 시, 제일 처음 실행되어 인스턴스를 반환한다.\n__init__: 새로운 객체를 생성 시,  __new__ 다음으로 실행되어 객체의 속성을 초기화한다.\n__del__: 객체 소멸 시 실행된다.\n__getattr__: 객체의 없는 속성을 참조하려 할 때 실행된다.\n__setattr__: 객체의 속성을 변경할 때 실행된다.\n__delattr__: 객체의 속성을 del 키워드로 지울 때 실행된다.\n__add__: 두 객체가 더하기를 할 때 실행된다.\n__sub__: 두 객체가 빼기를 할 때 실행된다.\n__mul__: 두 객체가 곱하기를 할 때 실행된다.\n__truediv__: 두 객체가 나누기를 할 때 실행된다.\n__doc__: Docstring을 출력한다.\ndir(객체명): 객체의 매직 메서드를 조회"
        },
        {
            "question": "클래스의 상속",
            "answer": "기존 클래스에 있는 속성과 메소드를 그대로 상속받아 새로운 클래스를 생성\n\n공통된 클래스를 부모로 두고 자식들이 상속을 받아 클래스를 생성하므로 일관성 있는 프로그래밍 가능\n\n기존 클래스에서 일부를 추가/변경한 새로운 클래스 생성으로 코드 재사용 가능"
        },
        {
            "question": "클래스 다중 상속",
            "answer": "2개 이상의 클래스를 상속받는 경우를 의미\n\n상속 받은 모든 클래스의 속성과 메소드를 사용 가능\n각 부모클래스를 가져오려면 super() 대신 각 클래스명을 써줌"
        },
        {
            "question": "클래스의 다형성",
            "answer": "같은 이름의 메소드가 다른 클래스에서 서로 다른 동작을 하는 것을 의미\n\n여러 객체 타입을 하나의 타입으로 관리 가능케 하여 코드의 양을 줄이고 유지보수에 좋음"
        },
        {
            "question": "클래스 설계 설명",
            "answer": "1. 단일 책임의 원칙: 클래스는 하나의 기능만 가지며 그에 대한 책임에 집중한다\n\n2. 개방 폐쇄 원칙: 하나의 클래스가 변경이 발생할 때, 다른 클래스로 변경에 대한 요구가 전파되지 않아야 한다. 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.\n\n3. 리스코프 치환 법칙: 자식 클래스는 언제나 부모클래스와 교체할 수 있다. 자식 클래스는 부모클래스가 약속한 규약을 지켜야 한다.\n\n4. 인터페이스 분리 원칙: 현재의 클래스가 사용하지 않는 메소드에 의존되지 않아야 한다. 너무 범용적인 클래스를 상속받거나 많은 클래스를 상속받으면(많은 메소드가 생기면) 안된다.\n\n5. 의존성 역전의 원칙: 자식클래스의 변경이 부모클래스의 변경을 요구해서는 안된다. 부모 클래스는 자식 클래스의 구현에 의존해서는 안된다."
        }
    ]


}
